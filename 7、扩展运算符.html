<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>
<script>
    //扩展运算符，是一个（...）,它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列
    // var arr = [1, 2, 3];

    // function test(x, y, z) {
    //     let a = x + y + z;
    //     alert(a)
    // }
    // test(...arr);


    //复制数组
    // 方法一
    // var arr = [1, 2, 3];
    // var a2 = arr.concat();
    // arr[0] = "a";
    // console.log(arr, a2);


    // 方法二
    // var a1 = [1, 2, 3];
    // var a2 = [...a1];
    // console.log(a2);


    // 方法三
    // var a1 = [1, 2, 3];
    // var [...a2] = a1;
    // console.log(a2);


    // 合并数组     
    // const arr1 = ['a', 'b'];
    // const arr2 = ['c'];
    // const arr3 = ['d', 'e'];
    // ES5 的合并数组
    // var arr = arr1.concat(arr2, arr3);
    // console.log(arr, arr1);
    // (5) ["a", "b", "c", "d", "e"] (2) ["a", "b"]

    // ES6 的合并数组
    // var arr = [...arr1, ...arr2, ...arr3];
    // console.log(arr, arr1);
    // (5) ["a", "b", "c", "d", "e"](2) ["a", "b"]

    // 扩展运算符提供了数组合并的新写法。不过，这两种方法都是浅拷贝，使用的时候需要注意。

    // var a1 = [{
    //     foo: 1
    // }];
    // var a2 = [{
    //     bar: 2
    // }];

    // var a3 = a1.concat(a2);
    // var a4 = [...a1, ...a2];

    // a1[0].foo = 2;
    // console.log(a3, a4);

    // a3[0] === a1[0] // true
    // a4[0] === a1[0] // true


    // 与解构赋值结合
    // var list = [1, 2, 3, 4];
    // var [a, ...rest] = list
    // console.log(a, rest)
    // // 1 (3) [2, 3, 4]


    // 字符串    扩展运算符还可以将字符串转为真正的数组。
    // var x = "hello";
    // var arr = [...x];
    // console.log(arr, typeof arr);
    // (5) ["h", "e", "l", "l", "o"]


    // Array.from()   方法用于将两类对象转为真正的数组
    // var list = {
    //     "0": "a",
    //     "1": "b",
    //     "length": 2
    // };
    // var newarr = Array.from(list, function(value) {
    //     return value + "1"
    // });
    // console.log(newarr);
    // // (2) ["a1", "b1"]



    // Array.of()   Array.of方法用于将一组值，转换为数组。
    // var a = Array.of(3, 11, 8);
    // var b = Array.of(3);
    // console.log(a, b)



    // 数组实例的 copyWithin()     
    // 数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），
    // 然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

    // var arr = [1, 2, "a", "b", 3];
    // arr.copyWithin(0, 2, 4);
    // console.log(arr);
    // (5) ["a", "b", "a", "b", 3]



    // 数组实例的 find() 和 findIndex()
    // 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第
    // 一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
    // 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

    // var arr = [1, 2, 5, 6, 3];
    // var x = arr.find((a) => a > 5);
    // console.log(x);
    // // 6
    // 等同于
    // var arr = [1, 2, 5, 6, 3];
    // var x = arr.find(function(value) {
    //     return value > 5
    // });
    // console.log(x);
    // // 6



    // var f = [NaN].indexOf(NaN);
    // console.log(f);
    // // -1

    // var f = [NaN].findIndex(y => Object.is(NaN, y));
    // console.log(f);
    // // 0


    // let arr1 = [{product: 'bread 700g',quantity: 2,unitCost: 90},{ product: 'milk 500ml',quantity: 1,unitCost: 47},{product: "Coffee 500gm", quantity: 1, unitCost: 250}]
    // let arr2 = [{product: 'bread 700g',quantity: 2,unitCost: 90},{ product: 'milk 500ml',quantity: 1,unitCost: 47}]
    // var newarr = {...arr1,arr2}
    // console.log(newarr)
    


    // var data = [{a:1},{ b:4}, {a:7}, {d:12}, {e:21}];
    // var result = data.filter(item => item.a !== 1);
    // console.log(result);

    // let arr1 = [{a:1},{ b:4}, {a:7}, {d:12}, {e:21}];
    // let arr2 = [{ b:4}, {a:7}, {d:12}, {e:21}]
    // var newarr = {...arr1,arr2}
    // console.log(newarr)



</script>

</html>